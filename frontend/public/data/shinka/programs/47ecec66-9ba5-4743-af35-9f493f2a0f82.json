{
  "id": "47ecec66-9ba5-4743-af35-9f493f2a0f82",
  "code": "# EVOLVE-BLOCK-START\n\"\"\"Gradient-descent based circle packing optimization for n=26 circles\"\"\"\n\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii using gradient descent.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Try multiple initial configurations\n    initial_configs = [\n        generate_grid_init(n),\n        generate_hex_init(n),\n        generate_optimal_seed(n),\n        generate_corner_focused(n),\n        generate_best_known_pattern(n),\n    ]\n\n    # Add random perturbations of best known pattern\n    for seed in range(5):\n        np.random.seed(seed * 13 + 7)\n        base = generate_best_known_pattern(n)\n        base += np.random.uniform(-0.03, 0.03, (n, 2))\n        base = np.clip(base, 0.05, 0.95)\n        initial_configs.append(base)\n\n    for _ in range(3):\n        initial_configs.append(generate_random_init(n))\n\n    for init_centers in initial_configs:\n        centers, radii = optimize_packing(init_centers.copy(), n, iterations=600)\n        sum_r = np.sum(radii)\n        if sum_r > best_sum:\n            best_sum = sum_r\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    # Final local search refinement\n    best_centers, best_radii = local_search_refinement(best_centers, best_radii, iterations=400)\n\n    return best_centers, best_radii\n\n\ndef generate_grid_init(n):\n    \"\"\"Generate initial positions on a grid\"\"\"\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    centers = []\n    spacing_x = 1.0 / (cols + 1)\n    spacing_y = 1.0 / (rows + 1)\n    for i in range(n):\n        row = i // cols\n        col = i % cols\n        x = (col + 1) * spacing_x\n        y = (row + 1) * spacing_y\n        centers.append([x, y])\n    return np.array(centers[:n])\n\n\ndef generate_hex_init(n):\n    \"\"\"Generate initial positions in hexagonal pattern\"\"\"\n    centers = []\n    rows = int(np.ceil(np.sqrt(n * 2 / np.sqrt(3))))\n    cols = int(np.ceil(n / rows)) + 1\n    spacing = 1.0 / (cols + 0.5)\n\n    for row in range(rows + 1):\n        y = 0.1 + row * spacing * np.sqrt(3) / 2\n        if y > 0.9:\n            break\n        offset = spacing / 2 if row % 2 else 0\n        for col in range(cols + 1):\n            x = 0.1 + offset + col * spacing\n            if x > 0.9:\n                break\n            if len(centers) < n:\n                centers.append([x, y])\n\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    return np.array(centers[:n])\n\n\ndef generate_random_init(n):\n    \"\"\"Generate random initial positions\"\"\"\n    return np.random.uniform(0.1, 0.9, (n, 2))\n\n\ndef generate_optimal_seed(n):\n    \"\"\"Generate positions based on known good patterns for n=26\"\"\"\n    centers = []\n    # 4 corner circles\n    margin = 0.08\n    for x in [margin, 1-margin]:\n        for y in [margin, 1-margin]:\n            centers.append([x, y])\n\n    # Edge circles (3 per edge, not corners)\n    for i in range(3):\n        t = (i + 1) / 4\n        centers.append([t, margin])\n        centers.append([t, 1-margin])\n        centers.append([margin, t])\n        centers.append([1-margin, t])\n\n    # Inner circles in a pattern\n    inner_positions = [\n        [0.5, 0.5],\n        [0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7],\n        [0.5, 0.3], [0.5, 0.7], [0.3, 0.5], [0.7, 0.5],\n        [0.5, 0.15]\n    ]\n    centers.extend(inner_positions)\n\n    return np.array(centers[:n])\n\n\ndef generate_corner_focused(n):\n    \"\"\"Generate with emphasis on corner efficiency\"\"\"\n    centers = []\n    # Corners get small circles\n    c = 0.05\n    for x in [c, 1-c]:\n        for y in [c, 1-c]:\n            centers.append([x, y])\n\n    # Edges\n    for i in range(4):\n        t = (i + 1) / 5\n        centers.append([t, 0.05])\n        centers.append([t, 0.95])\n    for i in range(2):\n        t = (i + 1) / 3\n        centers.append([0.05, t])\n        centers.append([0.95, t])\n\n    # Interior\n    for i in range(n - len(centers)):\n        x = 0.2 + 0.6 * ((i % 4) / 3)\n        y = 0.2 + 0.6 * ((i // 4) / 2)\n        centers.append([x, y])\n\n    return np.array(centers[:n])\n\n\ndef generate_best_known_pattern(n):\n    \"\"\"Pattern based on best known solutions for n=26\"\"\"\n    centers = np.array([\n        [0.48, 0.24], [0.08, 0.92], [0.37, 0.93], [0.38, 0.09],\n        [0.35, 0.75], [0.81, 0.33], [0.65, 0.66], [0.62, 0.43],\n        [0.68, 0.28], [0.08, 0.08], [0.89, 0.74], [0.09, 0.51],\n        [0.88, 0.51], [0.92, 0.92], [0.25, 0.91], [0.86, 0.14],\n        [0.94, 0.33], [0.13, 0.72], [0.25, 0.09], [0.37, 0.23],\n        [0.55, 0.12], [0.14, 0.29], [0.52, 0.89], [0.36, 0.51],\n        [0.52, 0.31], [0.74, 0.89]\n    ])\n    return centers[:n]\n\n\ndef local_search_refinement(centers, radii, iterations=300):\n    \"\"\"Fine-tune positions using local search with adaptive step size\"\"\"\n    n = centers.shape[0]\n    best_sum = np.sum(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n\n    step_size = 0.02\n\n    for iteration in range(iterations):\n        current_step = step_size * (1 - 0.7 * iteration / iterations)\n        improved = False\n\n        for i in range(n):\n            for dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)]:\n                test_centers = best_centers.copy()\n                test_centers[i, 0] += dx * current_step\n                test_centers[i, 1] += dy * current_step\n\n                if 0.01 < test_centers[i, 0] < 0.99 and 0.01 < test_centers[i, 1] < 0.99:\n                    test_radii = compute_max_radii(test_centers)\n                    test_sum = np.sum(test_radii)\n\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test_centers.copy()\n                        best_radii = test_radii.copy()\n                        improved = True\n\n        # Random jumps if stuck\n        if not improved and iteration % 30 == 0:\n            for _ in range(5):\n                i = np.random.randint(n)\n                test_centers = best_centers.copy()\n                test_centers[i] += np.random.uniform(-0.05, 0.05, 2)\n                test_centers[i] = np.clip(test_centers[i], 0.02, 0.98)\n                test_radii = compute_max_radii(test_centers)\n                test_sum = np.sum(test_radii)\n                if test_sum > best_sum:\n                    best_sum = test_sum\n                    best_centers = test_centers.copy()\n                    best_radii = test_radii.copy()\n\n    return best_centers, best_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum valid radii for given centers\"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # Distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Iteratively adjust for overlaps\n    for _ in range(10):\n        changed = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-10:\n                    dist = 1e-10\n                if radii[i] + radii[j] > dist:\n                    scale = dist / (radii[i] + radii[j]) * 0.9999\n                    radii[i] *= scale\n                    radii[j] *= scale\n                    changed = True\n        if not changed:\n            break\n\n    return radii\n\n\ndef optimize_packing(centers, n, iterations=600):\n    \"\"\"Optimize circle positions using gradient descent\"\"\"\n    lr = 0.012\n\n    for iteration in range(iterations):\n        radii = compute_max_radii(centers)\n        gradients = np.zeros_like(centers)\n\n        # Compute gradients based on how moving affects potential radii\n        eps = 0.0008\n        for i in range(n):\n            for dim in range(2):\n                centers[i, dim] += eps\n                radii_plus = compute_max_radii(centers)\n                sum_plus = np.sum(radii_plus)\n\n                centers[i, dim] -= 2 * eps\n                radii_minus = compute_max_radii(centers)\n                sum_minus = np.sum(radii_minus)\n\n                centers[i, dim] += eps  # restore\n                gradients[i, dim] = (sum_plus - sum_minus) / (2 * eps)\n\n        # Add repulsion from walls to prevent edge clustering\n        wall_margin = 0.02\n        for i in range(n):\n            x, y = centers[i]\n            if x < wall_margin:\n                gradients[i, 0] += 0.1 * (wall_margin - x)\n            if x > 1 - wall_margin:\n                gradients[i, 0] -= 0.1 * (x - (1 - wall_margin))\n            if y < wall_margin:\n                gradients[i, 1] += 0.1 * (wall_margin - y)\n            if y > 1 - wall_margin:\n                gradients[i, 1] -= 0.1 * (y - (1 - wall_margin))\n\n        # Update positions\n        centers += lr * gradients\n\n        # Clip to valid range\n        centers = np.clip(centers, 0.01, 0.99)\n\n        # Decay learning rate\n        if iteration % 100 == 99:\n            lr *= 0.7\n\n    radii = compute_max_radii(centers)\n    return centers, radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii = construct_packing()\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii",
  "parent_id": "7b54c75b-73e6-47cb-b8d9-ddbc432e4fe8",
  "generation": 17,
  "iteration_found": 17,
  "metrics": {
    "validity": 1.0,
    "sum_radii": 2.476050053596447,
    "target_ratio": 0.9396774396950465,
    "combined_score": 0.9396774396950465
  },
  "island": 0,
  "changes": "",
  "parent_metrics": {
    "validity": 1.0,
    "sum_radii": 2.4012614907693197,
    "target_ratio": 0.9112946834039165,
    "combined_score": 0.9112946834039165
  },
  "first_seen_checkpoint": 17,
  "circles": {
    "centers": [
      [
        0.42524983513909115,
        0.2999419270222448
      ],
      [
        0.08364630536846945,
        0.917128733726436
      ],
      [
        0.3893157345741674,
        0.9505473563091688
      ],
      [
        0.3474561104952344,
        0.06607898254344476
      ],
      [
        0.37934154288046423,
        0.738553930069762
      ],
      [
        0.7787432573254448,
        0.27474348020950556
      ],
      [
        0.6246379823479615,
        0.6496640628248146
      ],
      [
        0.6564789238576114,
        0.4062023826285018
      ],
      [
        0.6698108583101816,
        0.10879390203743557
      ],
      [
        0.07251669132803709,
        0.07178290830390316
      ],
      [
        0.8847141524067923,
        0.7274681706626788
      ],
      [
        0.08714280633483254,
        0.4785733675240612
      ],
      [
        0.8648160992004593,
        0.4799130314390768
      ],
      [
        0.9182637601357191,
        0.9191156748373294
      ],
      [
        0.26470129175246926,
        0.9020863834879108
      ],
      [
        0.8887611337470414,
        0.10982689694423907
      ],
      [
        0.9328967790117335,
        0.28751650419233854
      ],
      [
        0.1394700317453317,
        0.7002403871105762
      ],
      [
        0.22231468004261443,
        0.0779900897194096
      ],
      [
        0.34451564965554826,
        0.20601997018683613
      ],
      [
        0.47651319204308556,
        0.08636763238428592
      ],
      [
        0.13008130694278722,
        0.26330487845154676
      ],
      [
        0.5202756301038586,
        0.8929592434515834
      ],
      [
        0.3504051671477425,
        0.4684218120045514
      ],
      [
        0.5279138227806052,
        0.26633330747641826
      ],
      [
        0.7338469150718213,
        0.8924051398675317
      ]
    ],
    "radii": [
      0.005783642660908893,
      0.082871266273564,
      0.03518658167709327,
      0.044412442255662654,
      0.10204783722860426,
      0.0880909077366745,
      0.1566872244949318,
      0.08782066055532516,
      0.1081671727421748,
      0.07110785891739943,
      0.11410970979511603,
      0.08714280633483254,
      0.1330718082015442,
      0.07970336583021377,
      0.09759181510757027,
      0.10943673524321422,
      0.06657542129953722,
      0.1394700317453317,
      0.0779900897194096,
      0.09162186167695306,
      0.08580119325899561,
      0.12885801704659675,
      0.10695814163596416,
      0.16823088635875233,
      0.10072007086801978,
      0.106592504932057
    ]
  }
}