{
  "id": "c2b23643-2047-4447-a1b4-6f4b752f3205",
  "code": "# EVOLVE-BLOCK-START\n\"\"\"Voronoi-based basin-hopping optimizer for n=26 circle packing\"\"\"\n\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    using Voronoi-based initialization and basin-hopping optimization.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    # Generate diverse initial configurations\n    configs = []\n    \n    # Config 1: Lloyd's algorithm (Voronoi relaxation)\n    configs.append(lloyd_initialization(n, iterations=50))\n    \n    # Config 2: Sequential greedy placement\n    configs.append(sequential_greedy_placement(n))\n    \n    # Config 3: Best known pattern\n    configs.append(get_best_known_pattern())\n    \n    # Config 4-6: Perturbed best patterns\n    for seed in [13, 27, 41]:\n        np.random.seed(seed)\n        base = get_best_known_pattern()\n        base += np.random.uniform(-0.03, 0.03, (n, 2))\n        configs.append(np.clip(base, 0.03, 0.97))\n    \n    # Config 7: Poisson disk sampling\n    configs.append(poisson_disk_sampling(n))\n    \n    # Config 8-10: Random Voronoi\n    for seed in [7, 17, 37]:\n        np.random.seed(seed)\n        configs.append(lloyd_initialization(n, iterations=30))\n    \n    for config in configs:\n        # Basin-hopping optimization\n        centers, radii = basin_hopping_optimize(config.copy(), n)\n        total = np.sum(radii)\n        \n        if total > best_sum:\n            best_sum = total\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Final intensive refinement on best solution\n    best_centers, best_radii = intensive_local_search(best_centers, iterations=800)\n    \n    return best_centers, best_radii\n\n\ndef lloyd_initialization(n, iterations=50):\n    \"\"\"Initialize using Lloyd's algorithm (Voronoi relaxation).\"\"\"\n    # Start with random points\n    centers = np.random.uniform(0.1, 0.9, (n, 2))\n    \n    for _ in range(iterations):\n        # Simple approximation: move each point toward centroid of its Voronoi cell\n        # Using nearest-neighbor approximation\n        new_centers = centers.copy()\n        \n        # Sample grid points\n        grid_size = 30\n        grid_x, grid_y = np.meshgrid(\n            np.linspace(0.02, 0.98, grid_size),\n            np.linspace(0.02, 0.98, grid_size)\n        )\n        grid_points = np.column_stack([grid_x.ravel(), grid_y.ravel()])\n        \n        # Assign each grid point to nearest center\n        for i in range(n):\n            # Find grid points closest to center i\n            distances = np.linalg.norm(grid_points - centers[i], axis=1)\n            all_distances = np.array([np.linalg.norm(grid_points - c, axis=1) for c in centers])\n            closest = np.argmin(all_distances, axis=0)\n            my_points = grid_points[closest == i]\n            \n            if len(my_points) > 0:\n                centroid = np.mean(my_points, axis=0)\n                new_centers[i] = 0.7 * centers[i] + 0.3 * centroid\n        \n        centers = np.clip(new_centers, 0.04, 0.96)\n    \n    return centers\n\n\ndef sequential_greedy_placement(n):\n    \"\"\"Place circles one by one in optimal positions.\"\"\"\n    centers = []\n    \n    # First circle at center\n    centers.append([0.5, 0.5])\n    \n    for _ in range(n - 1):\n        best_pos = None\n        best_min_dist = 0\n        \n        # Try many candidate positions\n        for _ in range(500):\n            pos = np.random.uniform(0.05, 0.95, 2)\n            \n            # Distance to walls\n            wall_dist = min(pos[0], pos[1], 1 - pos[0], 1 - pos[1])\n            \n            # Distance to existing circles\n            if centers:\n                circle_dists = [np.linalg.norm(pos - c) for c in centers]\n                min_circle_dist = min(circle_dists)\n            else:\n                min_circle_dist = 1.0\n            \n            # Effective available radius\n            effective = min(wall_dist, min_circle_dist / 2)\n            \n            if effective > best_min_dist:\n                best_min_dist = effective\n                best_pos = pos\n        \n        centers.append(best_pos)\n    \n    return np.array(centers)\n\n\ndef poisson_disk_sampling(n, min_dist=0.12):\n    \"\"\"Generate points using Poisson disk sampling.\"\"\"\n    centers = []\n    active = []\n    \n    # First point\n    first = np.random.uniform(0.1, 0.9, 2)\n    centers.append(first)\n    active.append(first)\n    \n    k = 30  # Candidates per active point\n    \n    while len(centers) < n and active:\n        idx = np.random.randint(len(active))\n        point = active[idx]\n        found = False\n        \n        for _ in range(k):\n            # Generate candidate in annulus\n            angle = np.random.uniform(0, 2 * np.pi)\n            radius = np.random.uniform(min_dist, 2 * min_dist)\n            candidate = point + radius * np.array([np.cos(angle), np.sin(angle)])\n            \n            # Check bounds\n            if 0.05 < candidate[0] < 0.95 and 0.05 < candidate[1] < 0.95:\n                # Check distance to all existing points\n                valid = all(np.linalg.norm(candidate - c) >= min_dist * 0.9 for c in centers)\n                if valid:\n                    centers.append(candidate)\n                    active.append(candidate)\n                    found = True\n                    break\n        \n        if not found:\n            active.pop(idx)\n    \n    # Fill remaining with random points if needed\n    while len(centers) < n:\n        centers.append(np.random.uniform(0.1, 0.9, 2))\n    \n    return np.array(centers[:n])\n\n\ndef get_best_known_pattern():\n    \"\"\"Return the best known pattern from previous runs.\"\"\"\n    return np.array([\n        [0.4428, 0.3942], [0.8899, 0.5272], [0.7348, 0.6970], [0.4403, 0.7021],\n        [0.2815, 0.4745], [0.3832, 0.2518], [0.6710, 0.3765], [0.9346, 0.6612],\n        [0.9216, 0.8045], [0.7959, 0.9123], [0.4399, 0.9300], [0.2709, 0.8987],\n        [0.1410, 0.6952], [0.1292, 0.2769], [0.2434, 0.0897], [0.3947, 0.0636],\n        [0.7641, 0.1010], [0.9086, 0.2278], [0.9300, 0.3874], [0.0772, 0.0769],\n        [0.9309, 0.0689], [0.0854, 0.9145], [0.9407, 0.9406], [0.5582, 0.1044],\n        [0.6079, 0.8987], [0.0801, 0.4813]\n    ])\n\n\ndef compute_radii(centers, iterations=50):\n    \"\"\"Compute maximum valid radii.\"\"\"\n    n = centers.shape[0]\n    radii = np.array([min(c[0], c[1], 1-c[0], 1-c[1]) for c in centers])\n    \n    for _ in range(iterations):\n        changed = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-10:\n                    dist = 1e-10\n                if radii[i] + radii[j] > dist:\n                    total = radii[i] + radii[j]\n                    scale = dist / total * 0.99999\n                    radii[i] *= scale\n                    radii[j] *= scale\n                    changed = True\n        if not changed:\n            break\n    return radii\n\n\ndef basin_hopping_optimize(centers, n, hops=50, local_iters=100):\n    \"\"\"Basin-hopping: alternate between local optimization and random jumps.\"\"\"\n    best_centers = centers.copy()\n    best_radii = compute_radii(centers)\n    best_sum = np.sum(best_radii)\n    \n    current_centers = centers.copy()\n    current_sum = best_sum\n    \n    temperature = 0.08\n    \n    for hop in range(hops):\n        # Local optimization\n        current_centers = local_gradient_optimize(current_centers, iterations=local_iters)\n        current_radii = compute_radii(current_centers)\n        current_sum = np.sum(current_radii)\n        \n        # Update best\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = current_centers.copy()\n            best_radii = current_radii.copy()\n        \n        # Random perturbation (hop)\n        hop_size = temperature * (1 - hop / hops)\n        \n        # Different hop strategies\n        hop_type = hop % 4\n        \n        if hop_type == 0:\n            # Move random subset\n            num_move = np.random.randint(2, 6)\n            indices = np.random.choice(n, num_move, replace=False)\n            for idx in indices:\n                current_centers[idx] += np.random.uniform(-hop_size, hop_size, 2)\n        \n        elif hop_type == 1:\n            # Swap two circles\n            i, j = np.random.choice(n, 2, replace=False)\n            current_centers[i], current_centers[j] = current_centers[j].copy(), current_centers[i].copy()\n        \n        elif hop_type == 2:\n            # Move circle to random empty area\n            idx = np.random.randint(n)\n            current_centers[idx] = np.random.uniform(0.1, 0.9, 2)\n        \n        else:\n            # Small global perturbation\n            current_centers += np.random.uniform(-hop_size * 0.3, hop_size * 0.3, (n, 2))\n        \n        current_centers = np.clip(current_centers, 0.02, 0.98)\n        \n        # Accept or reject (with probability)\n        new_radii = compute_radii(current_centers)\n        new_sum = np.sum(new_radii)\n        \n        if new_sum < current_sum - 0.1:\n            # Reject and restart from best\n            if np.random.random() > 0.3:\n                current_centers = best_centers.copy()\n                current_sum = best_sum\n    \n    return best_centers, best_radii\n\n\ndef local_gradient_optimize(centers, iterations=100):\n    \"\"\"Fast local gradient optimization.\"\"\"\n    n = centers.shape[0]\n    lr = 0.008\n    eps = 0.0005\n    \n    for it in range(iterations):\n        gradients = np.zeros_like(centers)\n        \n        for i in range(n):\n            for dim in range(2):\n                centers[i, dim] += eps\n                sum_plus = np.sum(compute_radii(centers, iterations=10))\n                centers[i, dim] -= 2 * eps\n                sum_minus = np.sum(compute_radii(centers, iterations=10))\n                centers[i, dim] += eps\n                gradients[i, dim] = (sum_plus - sum_minus) / (2 * eps)\n        \n        centers += lr * gradients\n        centers = np.clip(centers, 0.01, 0.99)\n        \n        if it % 30 == 29:\n            lr *= 0.8\n    \n    return centers\n\n\ndef intensive_local_search(centers, iterations=500):\n    \"\"\"Intensive coordinate descent refinement.\"\"\"\n    n = centers.shape[0]\n    best_centers = centers.copy()\n    best_radii = compute_radii(centers)\n    best_sum = np.sum(best_radii)\n    \n    directions = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1),\n                  (2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]\n    \n    for it in range(iterations):\n        step = 0.015 * (0.97 ** (it // 20))\n        \n        for i in range(n):\n            for dx, dy in directions:\n                test = best_centers.copy()\n                test[i, 0] += dx * step\n                test[i, 1] += dy * step\n                \n                if 0.005 < test[i, 0] < 0.995 and 0.005 < test[i, 1] < 0.995:\n                    test_radii = compute_radii(test, iterations=20)\n                    test_sum = np.sum(test_radii)\n                    if test_sum > best_sum:\n                        best_sum = test_sum\n                        best_centers = test.copy()\n                        best_radii = test_radii.copy()\n    \n    return best_centers, best_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii = construct_packing()\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii",
  "parent_id": "cbf4f2d0-1fb8-41ff-9a0f-4d19609f62f1",
  "generation": 18,
  "iteration_found": 18,
  "metrics": {
    "validity": 1.0,
    "sum_radii": 0,
    "target_ratio": 0,
    "combined_score": 0
  },
  "island": 0,
  "changes": "",
  "parent_metrics": {
    "validity": 1.0,
    "sum_radii": 2.483831038490098,
    "target_ratio": 0.9426303751385572,
    "combined_score": 0.9426303751385572
  },
  "first_seen_checkpoint": 18,
  "circles": null
}