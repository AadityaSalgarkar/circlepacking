{
  "id": "7f4eb3cc-1edd-44ef-8007-a4eee423cf43",
  "code": "# EVOLVE-BLOCK-START\n\"\"\"Modular basin-hopping optimization for n=26 circle packing\"\"\"\n\nimport numpy as np\n\n\nclass RadiiComputer:\n    \"\"\"Handles all radii computation with caching for efficiency\"\"\"\n    \n    @staticmethod\n    def compute(centers):\n        \"\"\"Compute maximum valid radii for given centers\"\"\"\n        n = centers.shape[0]\n        radii = np.zeros(n)\n        \n        # Distance to borders\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(x, y, 1 - x, 1 - y)\n        \n        # Pairwise distance constraints\n        for _ in range(15):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < 1e-10:\n                        dist = 1e-10\n                    overlap = radii[i] + radii[j] - dist\n                    if overlap > 0:\n                        factor = dist / (radii[i] + radii[j]) * 0.99999\n                        radii[i] *= factor\n                        radii[j] *= factor\n        \n        return radii\n\n\nclass ConfigurationFactory:\n    \"\"\"Generates diverse initial configurations\"\"\"\n    \n    @staticmethod\n    def create_all(n):\n        \"\"\"Generate all configuration types\"\"\"\n        configs = [\n            ConfigurationFactory.shifted_grid_5x5_plus1(n),\n            ConfigurationFactory.hexagonal_tight(n),\n            ConfigurationFactory.dual_ring_with_corners(n),\n            ConfigurationFactory.edge_interior_balanced(n),\n            ConfigurationFactory.quincunx_pattern(n),\n        ]\n        # Add random variations\n        for seed in [42, 123, 456]:\n            np.random.seed(seed)\n            configs.append(np.random.uniform(0.08, 0.92, (n, 2)))\n        return configs\n    \n    @staticmethod\n    def shifted_grid_5x5_plus1(n):\n        \"\"\"5x5 grid with offset rows plus center circle\"\"\"\n        centers = []\n        for i in range(5):\n            offset = 0.02 if i % 2 else 0\n            for j in range(5):\n                x = 0.10 + j * 0.20 + offset\n                y = 0.10 + i * 0.20\n                centers.append([x, y])\n        centers.append([0.5, 0.5])\n        return np.array(centers[:n])\n    \n    @staticmethod\n    def hexagonal_tight(n):\n        \"\"\"Tight hexagonal packing\"\"\"\n        centers = []\n        row_height = 0.165\n        col_spacing = 0.19\n        y = 0.085\n        row = 0\n        while len(centers) < n:\n            offset = col_spacing / 2 if row % 2 else 0\n            x = 0.095 + offset\n            while x < 0.95 and len(centers) < n:\n                centers.append([min(x, 0.92), min(y, 0.92)])\n                x += col_spacing\n            y += row_height\n            row += 1\n            if y > 0.95:\n                break\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        return np.array(centers[:n])\n    \n    @staticmethod\n    def dual_ring_with_corners(n):\n        \"\"\"Two concentric rings plus corner circles\"\"\"\n        centers = []\n        # 4 corners\n        m = 0.07\n        for x, y in [(m, m), (1-m, m), (m, 1-m), (1-m, 1-m)]:\n            centers.append([x, y])\n        # Inner ring - 6\n        for i in range(6):\n            angle = 2 * np.pi * i / 6 + np.pi / 6\n            centers.append([0.5 + 0.18 * np.cos(angle), 0.5 + 0.18 * np.sin(angle)])\n        # Middle ring - 8\n        for i in range(8):\n            angle = 2 * np.pi * i / 8\n            centers.append([0.5 + 0.32 * np.cos(angle), 0.5 + 0.32 * np.sin(angle)])\n        # Edge midpoints - 4\n        centers.extend([[0.5, m], [0.5, 1-m], [m, 0.5], [1-m, 0.5]])\n        # Fill remaining\n        extras = [[0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]]\n        for pos in extras:\n            if len(centers) < n:\n                centers.append(pos)\n        return np.array(centers[:n])\n    \n    @staticmethod\n    def edge_interior_balanced(n):\n        \"\"\"Balance between edge and interior circles\"\"\"\n        centers = []\n        # Perimeter: 4 corners + 3 per edge = 16\n        m = 0.075\n        for x, y in [(m, m), (1-m, m), (m, 1-m), (1-m, 1-m)]:\n            centers.append([x, y])\n        for i in range(3):\n            t = 0.25 + 0.25 * i\n            centers.extend([[t, m], [t, 1-m], [m, t], [1-m, t]])\n        # Interior 10 in 2 rows\n        for row, y_val in enumerate([0.35, 0.65]):\n            for col in range(5):\n                if len(centers) < n:\n                    centers.append([0.15 + col * 0.175, y_val])\n        return np.array(centers[:n])\n    \n    @staticmethod\n    def quincunx_pattern(n):\n        \"\"\"Quincunx (5-point dice) based pattern\"\"\"\n        centers = []\n        spacing = 0.22\n        for i in range(5):\n            for j in range(5):\n                x = 0.11 + j * spacing\n                y = 0.11 + i * spacing\n                centers.append([x, y])\n        # Add center\n        centers.append([0.5, 0.5])\n        return np.array(centers[:n])\n\n\nclass LocalOptimizer:\n    \"\"\"Gradient-based local optimization with momentum\"\"\"\n    \n    @staticmethod\n    def optimize(centers, iterations=300):\n        \"\"\"Run momentum-based gradient ascent\"\"\"\n        n = centers.shape[0]\n        velocity = np.zeros_like(centers)\n        lr = 0.008\n        momentum = 0.85\n        eps = 0.0008\n        \n        for it in range(iterations):\n            gradients = np.zeros_like(centers)\n            base_sum = np.sum(RadiiComputer.compute(centers))\n            \n            # Compute numerical gradients\n            for i in range(n):\n                for dim in range(2):\n                    centers[i, dim] += eps\n                    sum_plus = np.sum(RadiiComputer.compute(centers))\n                    centers[i, dim] -= 2 * eps\n                    sum_minus = np.sum(RadiiComputer.compute(centers))\n                    centers[i, dim] += eps\n                    gradients[i, dim] = (sum_plus - sum_minus) / (2 * eps)\n            \n            # Momentum update\n            velocity = momentum * velocity + lr * gradients\n            centers = centers + velocity\n            centers = np.clip(centers, 0.01, 0.99)\n            \n            # Adaptive learning rate\n            if it % 60 == 59:\n                lr *= 0.85\n        \n        return centers\n\n\nclass BasinHopper:\n    \"\"\"Basin hopping meta-heuristic for global optimization\"\"\"\n    \n    @staticmethod\n    def hop(centers, n_hops=8, perturbation_scale=0.12):\n        \"\"\"Perform basin hopping from initial configuration\"\"\"\n        best_centers = centers.copy()\n        best_radii = RadiiComputer.compute(centers)\n        best_sum = np.sum(best_radii)\n        \n        current_centers = LocalOptimizer.optimize(centers.copy(), iterations=250)\n        current_sum = np.sum(RadiiComputer.compute(current_centers))\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = current_centers.copy()\n            best_radii = RadiiComputer.compute(current_centers)\n        \n        for hop in range(n_hops):\n            # Random perturbation\n            scale = perturbation_scale * (0.8 ** (hop // 3))\n            perturbed = current_centers + np.random.randn(*current_centers.shape) * scale\n            perturbed = np.clip(perturbed, 0.02, 0.98)\n            \n            # Local optimization\n            optimized = LocalOptimizer.optimize(perturbed, iterations=200)\n            optimized_sum = np.sum(RadiiComputer.compute(optimized))\n            \n            # Accept if better\n            if optimized_sum > current_sum:\n                current_centers = optimized\n                current_sum = optimized_sum\n                \n                if optimized_sum > best_sum:\n                    best_sum = optimized_sum\n                    best_centers = optimized.copy()\n                    best_radii = RadiiComputer.compute(optimized)\n            else:\n                # Metropolis criterion for escaping\n                if np.random.random() < 0.15:\n                    current_centers = optimized\n                    current_sum = optimized_sum\n        \n        return best_centers, best_radii\n\n\nclass CoordinateRefiner:\n    \"\"\"Final refinement using coordinate-wise search\"\"\"\n    \n    @staticmethod\n    def refine(centers, iterations=150):\n        \"\"\"Refine positions one coordinate at a time\"\"\"\n        n = centers.shape[0]\n        best_centers = centers.copy()\n        best_sum = np.sum(RadiiComputer.compute(centers))\n        \n        step = 0.008\n        for it in range(iterations):\n            improved = False\n            current_step = step * (0.97 ** it)\n            \n            for i in range(n):\n                for dim in range(2):\n                    for direction in [-1, 1]:\n                        test_centers = best_centers.copy()\n                        test_centers[i, dim] += direction * current_step\n                        \n                        if 0.005 < test_centers[i, dim] < 0.995:\n                            test_sum = np.sum(RadiiComputer.compute(test_centers))\n                            if test_sum > best_sum:\n                                best_sum = test_sum\n                                best_centers = test_centers.copy()\n                                improved = True\n            \n            if not improved and current_step < 0.001:\n                break\n        \n        return best_centers, RadiiComputer.compute(best_centers)\n\n\ndef construct_packing():\n    \"\"\"\n    Main entry point: construct optimized 26-circle packing.\n    \n    Returns:\n        Tuple of (centers, radii)\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Phase 1: Generate diverse configurations\n    configurations = ConfigurationFactory.create_all(n)\n    \n    # Phase 2: Basin hopping on each configuration\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    for config in configurations:\n        centers, radii = BasinHopper.hop(config.copy())\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    # Phase 3: Coordinate-wise refinement\n    best_centers, best_radii = CoordinateRefiner.refine(best_centers)\n    \n    return best_centers, best_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii = construct_packing()\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
  "parent_id": "7b54c75b-73e6-47cb-b8d9-ddbc432e4fe8",
  "generation": 10,
  "iteration_found": 10,
  "metrics": {
    "validity": 1.0,
    "sum_radii": 0,
    "target_ratio": 0,
    "combined_score": 0
  },
  "island": 0,
  "changes": "",
  "parent_metrics": {
    "validity": 1.0,
    "sum_radii": 2.4012614907693197,
    "target_ratio": 0.9112946834039165,
    "combined_score": 0.9112946834039165
  },
  "first_seen_checkpoint": 10,
  "circles": null
}